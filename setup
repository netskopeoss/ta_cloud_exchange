#!/usr/bin/env python3
from enum import Enum
from getpass import getpass
import os
import stat as st
from os import stat
import re
import socket
import shutil
import subprocess
import platform
import urllib.request
import urllib.parse
import urllib.error
import time
import multiprocessing
import sys
import readline

DEFAULT_INPUTS = {
    "CORE_TAG": {
        "default": "crestsystems/netskope:core-latest",
        "skip": True,
        "help": "",
    },
    "UI_TAG": {
        "default": "crestsystems/netskope:ui-latest",
        "skip": True,
        "help": "",
    },
    "UI_PORT": {
        "default": 80,
        "skip": False,
        "help": "",
        "user_input": "Enter the port on which you want to access the Netskope CE UI",
    },
    "JWT_SECRET": {
        "default": "",
        "skip": False,
        "help": "",
        "mandatory": True,
        "user_input": "Enter a JWT Secret which will be used for signing the authentication tokens",
    },
    "MAINTENANCE_PASSWORD": {
        "default": "",
        "skip": False,
        # "help": "Enter maintenance password that will be used for docker services. This password can be set only once. ",
        "help": "",
        "mandatory": True,
        "user_input": "Enter maintenance password that will be used for RabbitMQ and MongoDB services (This password can be set only once)",
    },
    "MAINTENANCE_PASSWORD_ESCAPED": {
        "default": "",
        "skip": True,
        "help": "Enter maintenance password that will be used for docker services. This password can be set only once.",
    },
    "WATCHTOWER_TOKEN": {"default": "token", "skip": True, "help": ""},
    "DOCKER_USERNAME": {"default": "", "skip": True, "help": ""},
    "DOCKER_PASSWORD": {"default": "", "skip": True, "help": ""},
    "MAX_MAINTENANCE_WINDOW_MINUTES": {
        "default": 15,
        "skip": True,
        "help": "",
    },
    "PULL_THREADS": {"default": 4, "skip": True, "help": ""},
    "MAX_WAIT_ON_LOCK_IN_MINUTES": {"default": 240, "skip": True, "help": ""},
    "ENABLE_TLS_V_1_2": {
        "default": "No",
        "skip": False,
        "help": "",
        "user_input": "Do you want to enable TLSv1.2 along with TLSv1.3 for CE UI",
    },
    "REQUESTS_TIMEOUT": {"default": 300, "skip": True, "help": ""},
    "POPEN_TIMEOUT": {"default": 1800, "skip": True, "help": ""},
}

AVAILABLE_INPUTS = {}
CHECKS = {}

MIN_CPU = 2
MIN_MEM_KB = 3500000
MIN_DISK_BYTES = 20000000000
MIN_DOCKER_VERSION = "19.0.0"
MIN_DOCKER_COMPOSE_VERSION = "1.29.0"
MIN_PODMAN_VERSION = "3.4.2"
MIN_PODMAN_COMPOSE_VERSION = "1.0.3"

N = 4
CE_VERSION_1 = f"CE v{N}-latest"
CE_VERSION_2 = f"CE v{N-1}-latest"
CE_VERSION_3 = "CE beta-latest"
CORE_VERSION_1_TAG = f"netskopetechnicalalliances/cloudexchange:core{N}-latest"
UI_VERSION_1_TAG = f"netskopetechnicalalliances/cloudexchange:ui{N}-latest"
CORE_VERSION_2_TAG = f"netskopetechnicalalliances/cloudexchange:core{N-1}-latest"
UI_VERSION_2_TAG = f"netskopetechnicalalliances/cloudexchange:ui{N-1}-latest"
CORE_VERSION_BETA_TAG = f"netskopetechnicalalliances/cloudexchange:core{N}-beta"
UI_VERSION_BETA_TAG = f"netskopetechnicalalliances/cloudexchange:ui{N}-beta"

CORE_DEFAULT = "netskopetechnicalalliances/cloudexchange:core3-latest"
UI_DEFAULT = "netskopetechnicalalliances/cloudexchange:ui3-latest"
CORE_BETA_DEFAULT = "netskopetechnicalalliances/cloudexchange:core3-beta"
UI_BETA_DEFAULT = "netskopetechnicalalliances/cloudexchange:ui3-beta"

GIT_PLUGIN_REPO = "https://github.com/netskopeoss/ta_cloud_exchange_plugins.git"


class Status(Enum):
    PASS = ("PASS",)
    NOT_VERIFIED = ("COULDN'T VERIFY",)
    FAIL = "FAIL"


def print_banner():
    print(
        """
  _   _        _         _                          ____  _____ 
 | \ | |  ___ | |_  ___ | | __ ___   _ __    ___   / ___|| ____|
 |  \| | / _ \| __|/ __|| |/ // _ \ | '_ \  / _ \ | |    |  _|  
 | |\  ||  __/| |_ \__ \|   <| (_) || |_) ||  __/ | |___ | |___ 
 |_| \_| \___| \__||___/|_|\_\\\___/ | .__/  \___|  \____||_____|
  ___              _          _  _  |_|    _    _               
 |_ _| _ __   ___ | |_  __ _ | || |  __ _ | |_ (_)  ___   _ __  
  | | | '_ \ / __|| __|/ _` || || | / _` || __|| | / _ \ | '_ \ 
  | | | | | |\__ \| |_| (_| || || || (_| || |_ | || (_) || | | |
 |___||_| |_||___/ \__|\__,_||_||_| \__,_| \__||_| \___/ |_| |_|
                                                                                                                                                                                                                       
                                                                                                                                        
    """
    )


def print_warning(message):
    print(f"\033[1;93m[!] \033[0;37m{message}")


def print_fail(message):
    print(f"\033[1;31m[F] \033[1;37m{message}\033[0;37m")


def print_pass(message):
    print(f"\033[0;32m[P] \033[0;37m{message}")


def compare_versions(version1, version2):
    versions1 = [int(v) for v in version1.split(".")]
    versions2 = [int(v) for v in version2.split(".")]
    for i in range(max(len(versions1), len(versions2))):
        v1 = versions1[i] if i < len(versions1) else 0
        v2 = versions2[i] if i < len(versions2) else 0
        if v1 > v2:
            return True
        elif v1 < v2:
            return False
    return True


def put_proxy_in_env():
    try:
        with open(".env", "w") as f:
            for key, value in AVAILABLE_INPUTS.items():
                f.write(f"{key}={value}\n")
    except Exception as e:
        raise Exception(f"Error occurred while putting proxy variables: {e}")


def put_env_variable(inputs):
    try:
        with open(".env", "w") as f:
            for key, value in inputs.items():
                f.write(f"{key}={value}\n")
    except Exception as e:
        raise Exception(f"Error occurred while putting env variables: {e}")


def create_env_if_not_exist():
    try:
        with open(".env", "a") as f:
            pass
    except Exception as e:
        raise Exception(f"Error occurred while creating file: {e}")


def get_all_existed_env_variable():
    AVAILABLE_INPUTS["HTTP_PROXY"] = ""
    AVAILABLE_INPUTS["HTTPS_PROXY"] = ""
    AVAILABLE_INPUTS["DESTINATION_PATH"] = ""

    try:
        with open(".env", "r") as f:
            if os.stat(".env").st_size > 0:
                with open(f".env.{int(time.time())}", "w+") as backup:
                    for line in f.readlines():
                        backup.write(line)
                        key, value = line.split("=", 1)
                        AVAILABLE_INPUTS[key] = value.strip()
    except Exception as e:
        raise Exception(f"Error occurred while getting env variables: {e}")


def set_directory_permission(directory, command):
    p = None
    try:
        p = subprocess.Popen(
            command.split(),
            stderr=subprocess.PIPE,
            stdout=subprocess.PIPE,
            stdin=subprocess.PIPE,
        )
        out, err = p.communicate()
        if len(err) <= 0:
            return
        else:
            raise Exception(err.decode("utf-8"))
    except Exception as e:
        if p:
            p.kill()
        raise Exception(
            f"Error occurred while setting file permissions for {directory}. Error: {e}"
        )


def check_for_certs():
    try:
        cert_file = "data/ssl_certs/cte_cert.crt"
        key_file = "data/ssl_certs/cte_cert_key.key"
        if os.path.isfile(cert_file) and os.path.isfile(key_file):
            return True
        return False
    except Exception as e:
        raise Exception(
            f"Error occurred while checking for SSL certs. Error: {e}"
        )


def create_self_signed_ssl_certs():
    try:
        print(
            f"Generating self signed certificate with validity of one year..."
        )
        command = "openssl req -x509 -newkey rsa:4096 -keyout data/ssl_certs/cte_cert_key.key -out data/ssl_certs/cte_cert.crt -sha256 -days 365 -nodes -subj /CN=localhost -extensions extendedkeyusage -config data/ssl_certs/extendedkeyusage.txt"
        p = subprocess.Popen(
            command.split(),
            stderr=subprocess.PIPE,
            stdout=subprocess.PIPE,
            stdin=subprocess.PIPE,
        )
        out, err = p.communicate()
        if p.returncode == 0:
            print(f"{err.decode('utf-8')}\n")
            command = "sudo chmod 666 data/ssl_certs/cte_cert.crt"
            set_directory_permission("data/ssl_certs/cte_cert.crt", command)
            command_key = "sudo chmod 666 data/ssl_certs/cte_cert_key.key"
            set_directory_permission("data/ssl_certs/cte_cert_key.key", command_key)
        else:
            raise Exception(f"{err.decode('utf-8')}\n")
    except Exception as e:
        p.kill()
        raise Exception(
            f"Error occurred while generating self-signed ssl certificates. Error: {e}"
        )


def check_machine_specs():
    print("\nVerifying minimum system requirements...")
    print(
        '\033[1;37mNOTE: The actual system requirements depend on several criteria including data volume, # of plugins among others.\nIt is highly recommended to refer to the System Requirements section of the "User Guide".\033[0;37m'
    )
    # Check Memory
    try:
        with open("/proc/meminfo", "r") as f:
            lines = f.readlines()
            for line in lines:
                if line.startswith("MemTotal"):
                    memory = int(line.split()[1])
                    if memory < MIN_MEM_KB:
                        print_fail(
                            f"{round(memory/1000000, 1)}GB Memory (Minimum {round(MIN_MEM_KB/1000000)}GB required)"
                        )
                        CHECKS["Memory Check"] = Status.FAIL
                    else:
                        print_pass(f"{round(memory/1000000, 1)}GB Memory")
                        CHECKS["Memory Check"] = Status.PASS
    except Exception as e:
        # print(e)
        print_warning(f"Could not verify Memory information of the machine")
        CHECKS["Memory Check"] = Status.NOT_VERIFIED

    # Check CPUs
    try:
        cpu_cores = multiprocessing.cpu_count()
        if cpu_cores < MIN_CPU:
            print_fail(
                f"{cpu_cores} CPU(s) (Minimum {MIN_CPU} CPU(s) required)"
            )
            CHECKS["CPU Check"] = Status.FAIL
        else:
            print_pass(f"{cpu_cores} CPU(s)")
            CHECKS["CPU Check"] = Status.PASS
    except Exception as e:
        print_warning(f"Could not verify CPU information of the machine...")
        CHECKS["CPU Check"] = Status.NOT_VERIFIED

    # Check Disk Space
    try:
        path = "/var/lib/docker"
        if isRedHat() and not isRedHat79():
            path = "/var/lib/containers"
        disk_stats = shutil.disk_usage(path)
        free_space = disk_stats.free
        if free_space < MIN_DISK_BYTES:
            print_fail(
                f"{round(free_space/1000000000, 1)}GB free disk space (Minimum {round(MIN_DISK_BYTES/1000000000, 1)}GB free disk space is required)"
            )
            CHECKS["Disk Space Check"] = Status.FAIL
        else:
            print_pass(f"{round(free_space/1000000000, 1)}GB free disk space")
            CHECKS["Disk Space Check"] = Status.PASS
    except Exception as e:
        # print(e)
        print_warning(f"Could not verify Disk information of the machine")
        CHECKS["Disk Space Check"] = Status.NOT_VERIFIED

    # Check 15672 Port availability
    try:
        sock = socket.socket(socket.AF_INET, socket.SOCK_STREAM)
        result = sock.connect_ex(("127.0.0.1", 15672))
        if result == 0:
            print_fail(f"Port 15672 is already in use. (Please stop the Netskope CE instance if already running (using `./stop`) and re-run the setup script.)")
            CHECKS["Port Check"] = Status.FAIL
        else:
            print_pass(f"Port 15672 is available.")
            CHECKS["Port Check"] = Status.PASS
    except Exception as e:
        # print(e)
        print_warning(f"Could not verify Port information of the machine")
        CHECKS["Port Check"] = Status.NOT_VERIFIED

    if Status.FAIL in [
        CHECKS.get("Memory Check"),
        CHECKS.get("Disk Space Check"),
        CHECKS.get("CPU Check"),
        CHECKS.get("Port Check"),
    ]:
        print(
            "\033[1;31mOne or more system requirement checks have failed. Please ensure the minimum system requirements are met to proceed further. \033[0;37m"
        )


def check_docker_versions():
    try:
        regex = "(\d+(\.\d+){2,3})"
        command = "docker --version"
        p = subprocess.check_output(command, shell=True)
        docker_version = re.search(regex, p.decode("utf-8")).groups()[0]
        if compare_versions(docker_version, MIN_DOCKER_VERSION):
            print_pass(f"Docker Version {docker_version}")
            CHECKS["Docker"] = Status.PASS
        else:
            print_fail(
                f"Docker Version {docker_version} (Minimum {MIN_DOCKER_VERSION} is required)"
            )
            CHECKS["Docker"] = Status.FAIL

        command = "docker-compose --version"
        p = subprocess.check_output(command, shell=True)
        docker_compose_version = re.search(regex, p.decode("utf-8")).groups()[
            0
        ]
        if compare_versions(
            docker_compose_version, MIN_DOCKER_COMPOSE_VERSION
        ):
            print_pass(f"Docker Compose Version {docker_compose_version}")
            CHECKS["Docker-Compose"] = Status.PASS
        else:
            print_fail(
                f"Docker Compose Version {docker_compose_version} (Minimum {MIN_DOCKER_COMPOSE_VERSION} is required)"
            )
            CHECKS["Docker-Compose"] = Status.FAIL
    except Exception as e:
        CHECKS["Docker-Compose"] = Status.NOT_VERIFIED
        CHECKS["Docker"] = Status.NOT_VERIFIED
        raise Exception("Docker not found")


def check_podman_versions():
    try:
        regex = "(\d+(\.\d+){2,3})"
        command = "podman-compose --version"
        p = subprocess.check_output(command, shell=True)
        lines = p.decode("utf-8").splitlines()

        podman_version = ""
        for line in lines:
            if "podman version" in line:
                podman_version = re.search(regex, line).groups()[0]
                break

        if podman_version == "":
            raise
        if compare_versions(podman_version, MIN_PODMAN_VERSION):
            print_pass(f"Podman Version {podman_version}")
            CHECKS["Podman"] = Status.PASS
        else:
            print_fail(
                f"Podman Version {podman_version} (Minimum {MIN_PODMAN_VERSION} is required)"
            )
            CHECKS["Podman"] = Status.FAIL

        podman_compose_version = ""
        for line in lines:
            if "podman-compose" in line:
                podman_compose_version = re.search(regex, line).groups()[0]
                break

        if podman_compose_version == "":
            raise
        if compare_versions(
            podman_compose_version, MIN_PODMAN_COMPOSE_VERSION
        ):
            print_pass(f"Podman Compose Version {podman_compose_version}")
            CHECKS["Podman-Compose"] = Status.PASS
        else:
            print_fail(
                f"Podman Compose Version {podman_compose_version} (Minimum {MIN_PODMAN_COMPOSE_VERSION} is required)"
            )
            CHECKS["Podman-Compose"] = Status.FAIL

        command = "rpm -qa"
        p = subprocess.check_output(command, shell=True)
        lines = p.decode("utf-8").splitlines()

        is_plugin_present = False
        for line in lines:
            if line.startswith("podman-plugins"):
                is_plugin_present = True
                break

        if is_plugin_present:
            print_pass(f"Verified podman plugins are installed")
            CHECKS["Podman-Plugin"] = Status.PASS
        else:
            print_fail(
                f"Required podman plugins are not installed. (Run `yum install podman-plugins` and Re-run the script)"
            )
            CHECKS["Podman-Plugin"] = Status.FAIL

    except Exception as e:
        # print(e)
        CHECKS["Podman-Compose"] = Status.NOT_VERIFIED
        CHECKS["Podman-Plugin"] = Status.NOT_VERIFIED
        CHECKS["Podman"] = Status.NOT_VERIFIED
        raise Exception("Podman not found")


def validate_proxy(proxy, cur_proxy=None):
    if proxy == "" and cur_proxy is not None and len(cur_proxy) > 0:
        return True
    regex = "^(?:(.*))://(?:(.*))$"
    result = re.search(regex, proxy)
    if result is None:
        print("Invalid Proxy Provided...")
        return False
    parts = result.groups()
    if len(parts) < 2:
        print("Invalid Proxy Provided...")
        return False
    if parts[0] not in ["http", "https"]:
        print("Invalid Protocol Provided... Valid Protocols are http/https...")
        return False
    if parts[1] == " ":
        print("Invalid Hostname Provided... It should be valid IP/FQDN...")
        return False
    return True


def prepare_proxy(url, username=None, password=None):
    if (
        username is None
        or len(username) == 0
        or password is None
        or len(password) == 0
    ):
        return url
    prefix = "https://" if url.startswith("https://") else "http://"
    url = url.replace(prefix, "")

    username = urllib.parse.quote_plus(username)
    password = urllib.parse.quote_plus(password)
    return f"{prefix}{username}:{password}@{url}"


def parse_proxy(url):
    if url is None or len(url) == 0:
        return None

    url = urllib.parse.urlparse(url)
    if url.scheme is None:
        return f"{url.hostname}"
    if url.port is None:
        return f"{url.scheme}://{url.hostname}"
    return f"{url.scheme}://{url.hostname}:{url.port}"

def ask_for_ce_version():
    while True:
        current_version = ""
        if AVAILABLE_INPUTS.get("BETA_OPT_IN", "No").lower() in ["yes", "y"]:
            current_version = CE_VERSION_3
        elif CORE_VERSION_1_TAG == AVAILABLE_INPUTS.get("CORE_TAG", "").strip():
            current_version = CE_VERSION_1
        elif CORE_VERSION_2_TAG == AVAILABLE_INPUTS.get("CORE_TAG", "").strip():
            current_version = CE_VERSION_2

        if current_version == "":
            print(f"\nAvailable Netskope CE Versions\n\t 1. {CE_VERSION_1} \n\t 2. {CE_VERSION_2} \n\t 3. {CE_VERSION_3}\n")
        else:
            print(f"\nAvailable Netskope CE Versions (Current Version: {current_version})\n\t 1. {CE_VERSION_1} \n\t 2. {CE_VERSION_2} \n\t 3. {CE_VERSION_3}\n")
        n = input(
            "Select the version you want to install (1/2/3): "
        )
        try:
            n = int(n)
            if n not in [1, 2, 3]:
                print(f"{n} is not a valid selection.")
                continue
            break
        except Exception as err:
            print(err)
            print(f"{n} is not a valid selection.")
            continue
    if n == 1:
        AVAILABLE_INPUTS["CORE_TAG"] = CORE_VERSION_1_TAG
        AVAILABLE_INPUTS["UI_TAG"] = UI_VERSION_1_TAG
        AVAILABLE_INPUTS["BETA_OPT_IN"] = "No"
    elif n == 2:
        AVAILABLE_INPUTS["CORE_TAG"] = CORE_VERSION_2_TAG
        AVAILABLE_INPUTS["UI_TAG"] = UI_VERSION_2_TAG
        AVAILABLE_INPUTS["BETA_OPT_IN"] = "No"
    elif n == 3:
        AVAILABLE_INPUTS["CORE_TAG"] = CORE_VERSION_BETA_TAG
        AVAILABLE_INPUTS["UI_TAG"] = UI_VERSION_BETA_TAG
        AVAILABLE_INPUTS["BETA_OPT_IN"] = "yes"


def ask_for_initial_inputs():
    isProxy = (
        input(
            "\n\nAre you using HTTP(s) proxy for outbound traffic? [y/n]\n> "
        )
        .strip()
        .lower()
    )

    if isProxy == "y" or isProxy == "yes":
        # HTTPS_PROXY
        cur_https_proxy = parse_proxy(AVAILABLE_INPUTS["HTTPS_PROXY"])

        print(
            f"\nEnter Proxy URL (e.g. http(s)://10.0.0.0:3128)  {('(Current: ' + cur_https_proxy + ')') if cur_https_proxy is not None else ''}"
        )
        https_proxy = input("> ").strip()
        https_proxy_password = None
        while not validate_proxy(https_proxy, cur_https_proxy):
            print(
                f"\nEnter Proxy URL (e.g. http(s)://10.0.0.0:3128)  {('(Current: ' + cur_https_proxy + ')') if cur_https_proxy is not None else ''}"
            )
            https_proxy = input("> ").strip()
        if https_proxy is None or len(https_proxy) == 0:
            https_proxy = cur_https_proxy

        https_proxy_username = input(
            f"Enter proxy username (skip in case of unauthenticated proxy):\n> "
        ).strip()
        if https_proxy_username is not None and len(https_proxy_username) > 0:
            https_proxy_password = getpass(
                "Enter proxy password: \n> "
            ).strip()
            while https_proxy_password == "":
                print("Proxy password can not be empty... Please try again.\n")
                https_proxy_password = getpass(
                    "Enter proxy password: \n> "
                ).strip()

        AVAILABLE_INPUTS["HTTPS_PROXY"] = prepare_proxy(
            https_proxy,
            username=https_proxy_username,
            password=https_proxy_password,
        )
        AVAILABLE_INPUTS["HTTP_PROXY"] = AVAILABLE_INPUTS["HTTPS_PROXY"]

        print(
            "\n\033[1;37mNOTE: These proxy details will be reflected on the Settings > General > Proxy page on Netskope CE UI.\n\033[0;37m"
        )
    else:
        AVAILABLE_INPUTS["HTTP_PROXY"] = ""
        AVAILABLE_INPUTS["HTTPS_PROXY"] = ""

    tenant_name = ""
    while True:
        tenant_name = input(
            "\n> Please enter the Netskope Tenant Name (Exclude .goskope.com)\n(e.g. Enter 'demo' if Netskope Tenant URL is https://demo.goskope.com)\nPlease Enter 'test' if you do not have any Netskope tenant: "
        ).strip()
        if tenant_name == "" or "goskope.com" in tenant_name:
            print(
                "Tenant name can not be empty. It should be without '.goskope.com'..."
            )
        else:
            break
    AVAILABLE_INPUTS["NETSKOPE_TENANT"] = tenant_name


class ClientExceptions(Exception):
    pass


class ServerExceptions(Exception):
    pass


def handle_http_errors(res):
    status_code = res.code
    if status_code == 200:
        # raise ClientExceptions("Request Timeout Error.")
        return

    # Client Errors
    elif status_code == 400:
        raise ClientExceptions("Bad Request Error.")
    elif status_code == 401:
        raise ClientExceptions("Unauthorized Error.")
    elif status_code == 403:
        raise ClientExceptions("Forbidden Error.")
    elif status_code == 404:
        raise ClientExceptions("Not Found Error.")
    elif status_code == 408:
        raise ClientExceptions("Request Timeout Error.")

    # Server Errors
    elif status_code == 500:
        raise ServerExceptions("Internal Server Error.")
    elif status_code == 502:
        raise ServerExceptions("Bad Gateway Error.")
    elif status_code == 503:
        raise ServerExceptions("Service Unavailable Error.")
    elif status_code == 504:
        raise ServerExceptions("Gateway Timeout Error.")


def handle_connectivity(name, url):
    try:
        req = urllib.request.Request(url)
        proxy = None
        if AVAILABLE_INPUTS.get("HTTPS_PROXY", "") != "":
            proxy = AVAILABLE_INPUTS.get("HTTPS_PROXY")

        proxies = {}

        if proxy is not None:
            proxies["https"] = proxy

        proxy_support = urllib.request.ProxyHandler(proxies=proxies)
        opener = urllib.request.build_opener(proxy_support)
        urllib.request.install_opener(opener)

        res = urllib.request.urlopen(req, timeout=60)
        handle_http_errors(res)
        CHECKS[name] = Status.PASS
        print_pass(f"Connectivity to {url} verified successfully.")
    except ClientExceptions as e:
        print_fail(
            f"Error occurred while verifying connectivity to {url}: ClientError {e}"
        )
        CHECKS[name] = Status.FAIL
        raise
    except ServerExceptions as e:
        print_fail(
            f"Error occurred while verifying connectivity to {url}: ServerError {e}"
        )
        CHECKS[name] = Status.FAIL
        raise
    except urllib.error.HTTPError as e:
        print_fail(
            f"Error occurred while verifying connectivity to {url}: HTTPError {e}"
        )
        CHECKS[name] = Status.FAIL
        raise
    except urllib.error.URLError as e:
        print_fail(
            f"Error occurred while verifying connectivity to {url}: URLError {e}"
        )
        CHECKS[name] = Status.FAIL
        raise
    except Exception as e:
        print_fail(
            f"Error occurred while verifying connectivity to {url}: {e}"
        )
        CHECKS[name] = Status.FAIL
        raise


def check_github_connctivity():
    os.environ["HTTPS_PROXY"] = AVAILABLE_INPUTS.get("HTTPS_PROXY", "")
    command = f"git ls-remote {GIT_PLUGIN_REPO}"
    p = subprocess.Popen(
        command.split(),
        stderr=subprocess.PIPE,
        stdout=subprocess.PIPE,
        stdin=subprocess.PIPE,
    )
    # print(p)
    out, err = p.communicate()
    if p.returncode != 0:
        CHECKS["Github"] = Status.FAIL
        print_fail(f"Error occurred while verifying connectivity to https://github.com: {err}")
    else:
        CHECKS["Github"] = Status.PASS
        print_pass("Connectivity to https://github.com verified successfully")


def timeout(t, cmd, *args):
    pool = multiprocessing.Pool(processes=1)
    result = pool.apply_async(cmd, args=args)
    try:
        retval = result.get(timeout=t)
    except multiprocessing.TimeoutError as err:
        pool.terminate()
        pool.join()
        url = ""
        if len(args) == 0:
            CHECKS["Github"] = Status.FAIL
            url = "https://github.com"
        else:
            CHECKS[args[0]] = Status.FAIL
            url = args[1]
        print_fail(
            f"Error occurred while verifying connectivity to {url}: Timed out."
        )
    except Exception as err:
        if len(args) == 0:
            CHECKS["Github"] = Status.FAIL
        else:
            CHECKS[args[0]] = Status.FAIL
    else:
        return retval


def check_connectivity():
    # Check connectivity for github, docker and tenant
    print(
        "\nVerifying the connectivity for pre-requisite outbound network calls..."
    )
    timeout(60, check_github_connctivity)
    timeout(60, handle_connectivity, "Docker Hub", "https://hub.docker.com")

    print(
        '\033[1;37mNOTE: This connectivity check is only for the Docker Hub (https://hub.docker.com). Docker images are pulled from CDN. Please make sure that you have the required connectivity to pull the docker images.\033[0;37m'
    )

    tenant_name = AVAILABLE_INPUTS.get("NETSKOPE_TENANT")
    if tenant_name != "test":
        timeout(60, handle_connectivity, "Netskope tenant", f"https://{tenant_name}.goskope.com")

    if Status.FAIL in [
        CHECKS.get("Github"),
        CHECKS.get("Docker Hub"),
        CHECKS.get("Netskope tenant"),
    ]:
        print(
            "\033[1;31mOne or more connectivity checks have failed. Verify the network connectivity, proxy settings or firewall configurations to address the connectivity issues. \033[0;37m"
        )
    else:
        put_proxy_in_env()


def isRedHat():
    try:
        with open("/etc/redhat-release") as f:
            content = f.readline()
            if content.startswith("Red Hat"):
                return True
            else:
                return False
    except Exception as e:
        return False


def isRedHat79():
    try:
        with open("/etc/redhat-release") as f:
            content = f.readline()
            if content.startswith("Red Hat") and "7.9" in content:
                return True
            else:
                return False
    except Exception as e:
        return False


def check_prerequisites():
    check_connectivity()
    check_machine_specs()
    print("\nVerifying docker/podman prerequisites...")
    if isRedHat79():
        try:
            check_docker_versions()
        except Exception as e:
            print_fail(
                f"Could not verify Docker/Docker-compose version of the machine"
            )
    elif isRedHat():
        try:
            check_podman_versions()
        except Exception as e:
            print_fail(
                f"Could not verify Podman/Podman-compose/Podman-plugins version of the machine"
            )
    else:
        try:
            check_docker_versions()
        except Exception as e:
            try:
                check_podman_versions()
            except Exception as e:
                print_fail(
                    f"Could not verify Docker/Docker-compose version of the machine"
                )
                print_fail(
                    f"Could not verify Podman/Podman-compose/Podman-plugins version of the machine"
                )


def check_and_apply_file_permissions():
    print("\nVerifying required file permissions...")
    # Mongo-Data directory owner
    try:
        if not os.path.exists("data/mongo-data"):
            print_fail(
                f"Could not locate data/mongo-data directory (Please run `git reset --hard HEAD && git pull` and re-run the script.)"
            )
            CHECKS["MONGO"] = Status.FAIL
        else:
            if platform.system().lower() not in ["darwin"]:
                if (
                    stat("data/mongo-data").st_uid == 999
                    and stat("data/mongo-data").st_gid == 999
                ):
                    print_pass(
                        f"Verified owner of data/mongo-data is user with uid 999"
                    )
                    CHECKS["MONGO"] = Status.PASS
                else:
                    command = "sudo chown -R 999:999 data/mongo-data"
                    set_directory_permission("data/mongo-data", command)
                    print_pass(
                        f"Owner of data/mongo-data is not accurate... Changing owner of data/mongo-data to user with uid 999"
                    )
                    CHECKS["MONGO"] = Status.PASS

            # mongo_data directory file
            try:
                file_perms = oct(stat("data/mongo-data").st_mode & 0o777)
                if (
                    (int(file_perms[2]) & 4)
                    and (int(file_perms[2]) & 2)
                    and (int(file_perms[2]) & 1)
                    and (int(file_perms[3]) & 4)
                    and (int(file_perms[4]) & 4)
                ):
                    print_pass(f"Verified file permissions of data/mongo-data")
                    CHECKS["MONGO-FILE"] = Status.PASS
                else:
                    command = "sudo chmod -R 744 data/mongo-data"
                    set_directory_permission("data/mongo-data", command)
                    print_pass(
                        f"File permissions of data/mongo-data are not accurate... Adding read/write permissions to data/custom_plugins"
                    )
                    CHECKS["MONGO-FILE"] = Status.PASS
            except Exception as e:
                print_fail(
                    f"Error occurred while verifying file permissions for data/mongo-data"
                )
                CHECKS["MONGO-FILE"] = Status.FAIL
    except Exception as e:
        # print(e)
        print_fail(f"Error occurred while verifying owner of data/mongo-data")
        CHECKS["MONGO"] = Status.FAIL

    

    # Custom_plugins directory
    try:
        if not os.path.exists("data/custom_plugins"):
            print_fail(
                f"Could not locate data/custom_plugins directory (Please run `git reset --hard HEAD && git pull` and re-run the script.)"
            )
            CHECKS["CUSTOM_PLUGINS"] = Status.FAIL
        elif not os.path.exists("data/custom_plugins/__init__.py"):
            print_fail(
                f"Could not locate data/custom_plugins/__init__.py file (Please run `git reset --hard HEAD && git pull` and re-run the script.)"
            )
            CHECKS["CUSTOM_PLUGINS"] = Status.FAIL
        else:
            if platform.system().lower() not in ["darwin"]:
                if (
                    stat("data/custom_plugins").st_uid == 1001
                    and stat("data/custom_plugins").st_gid == 1001
                ):
                    print_pass(
                        f"Verified owner of data/custom_plugins is user with uid 1001"
                    )
                else:
                    command = "sudo chown -R 1001:1001 data/custom_plugins"
                    set_directory_permission("data/custom_plugins", command)
                    print_pass(
                        f"Owner of data/custom_plugins is not accurate... Changing owner of data/custom_plugins to user with uid 1001"
                    )
                CHECKS["CUSTOM_PLUGINS"] = Status.PASS

            try:
                file_perms = oct(stat("data/custom_plugins").st_mode & 0o777)
                if (
                    (int(file_perms[2]) & 4)
                    and (int(file_perms[2]) & 2)
                    and (int(file_perms[2]) & 1)
                    and (int(file_perms[3]) & 4)
                    and (int(file_perms[4]) & 4)
                ):
                    print_pass(f"Verified file permissions of data/custom_plugins")
                    CHECKS["CUSTOM_PLUGINS_FILE"] = Status.PASS
                else:
                    command = "sudo chmod -R 744 data/custom_plugins"
                    set_directory_permission("data/custom_plugins", command)
                    print_pass(
                        f"File permissions of data/custom_plugins are not accurate... Adding read/write permissions to data/custom_plugins"
                    )
                    CHECKS["CUSTOM_PLUGINS_FILE"] = Status.PASS
            except Exception as e:
                print_fail(
                    f"Error occurred while verifying file permissions for data/custom_plugins"
                )
                CHECKS["CUSTOM_PLUGINS_FILE"] = Status.FAIL

    except Exception as e:
        # print(e)
        print_fail(
            f"Error occurred while verifying file permissions for data/custom_plugins"
        )
        CHECKS["CUSTOM_PLUGINS"] = Status.FAIL

    # ssl_certs directory
    try:
        if not os.path.exists("data/ssl_certs"):
            print_fail(
                f"Could not locate data/ssl_certs directory (Please run `git reset --hard HEAD && git pull` and re-run the script.)"
            )
            CHECKS["SSL_CERTS"] = Status.FAIL
        else:
            if platform.system().lower() not in ["darwin"]:
                if (
                    stat("data/ssl_certs").st_uid == 1001
                    and stat("data/ssl_certs").st_gid == 1001
                ):
                    print_pass(
                        f"Verified owner of data/ssl_certs is user with uid 1001"
                    )
                    CHECKS["SSL_CERTS"] = Status.PASS
                else:
                    command = "sudo chown -R 1001:1001 data/ssl_certs"
                    set_directory_permission("data/ssl_certs", command)
                    print_pass(
                        f"Owner of data/ssl_certs is not accurate... Changing owner of data/ssl_certs to user with uid 1001"
                    )
                    CHECKS["SSL_CERTS"] = Status.PASS

            file_perms = oct(stat("data/ssl_certs").st_mode & 0o777)
            if (
                (int(file_perms[2]) & 4)
                and (int(file_perms[2]) & 2)
                and (int(file_perms[2]) & 1)
                and (int(file_perms[3]) & 4)
                and (int(file_perms[3]) & 2)
                and (int(file_perms[4]) & 4)
                and (int(file_perms[4]) & 2)
            ):
                print_pass(f"Verified file permissions of data/ssl_certs")
                CHECKS["SSL_CERTS"] = Status.PASS
            else:
                command = "sudo chmod 766 data/ssl_certs"
                set_directory_permission("data/ssl_certs", command)
                print_pass(
                    f"File permissions of data/ssl_certs are not accurate... Adding read/write permissions to data/ssl_certs"
                )
                CHECKS["SSL_CERTS"] = Status.PASS
        
        if os.path.exists("data/ssl_certs/cte_cert.crt"):
            file_perms = oct(stat("data/ssl_certs/cte_cert.crt").st_mode & 0o777)
            if not (
                (int(file_perms[2]) & 4)
                and (int(file_perms[2]) & 2)
                and (int(file_perms[3]) & 4)
                and (int(file_perms[3]) & 2)
                and (int(file_perms[4]) & 4)
                and (int(file_perms[4]) & 2)
            ): 
                command = "sudo chmod 666 data/ssl_certs/cte_cert.crt"
                set_directory_permission("data/ssl_certs/cte_cert.crt", command)
                print_pass(
                    f"File permissions of data/ssl_certs/cte_cert.crt are not accurate... Adding read/write permissions to data/ssl_certs/cte_cert.crt"
                )

        if os.path.exists("data/ssl_certs/cte_cert_key.key"):
            file_perms = oct(stat("data/ssl_certs/cte_cert_key.key").st_mode & 0o777)
            if not (
                (int(file_perms[2]) & 4)
                and (int(file_perms[2]) & 2)
                and (int(file_perms[3]) & 4)
                and (int(file_perms[3]) & 2)
                and (int(file_perms[4]) & 4)
                and (int(file_perms[4]) & 2)
            ): 
                command = "sudo chmod 666 data/ssl_certs/cte_cert_key.key"
                set_directory_permission("data/ssl_certs/cte_cert_key.key", command)
                print_pass(
                    f"File permissions of data/ssl_certs/cte_cert_key.key are not accurate... Adding read/write permissions to data/ssl_certs/cte_cert_key.key"
                )
            
    except Exception as e:
        print_fail(
            f"Error occurred while verifying file permissions for data/ssl_certs"
        )
        CHECKS["SSL_CERTS"] = Status.FAIL

    # rabbitmq directory
    try:
        if not os.path.exists("data/rabbitmq"):
            print_fail(
                f"Could not locate data/rabbitmq directory (Please run `git reset --hard HEAD && git pull` and re-run the script.)"
            )
            CHECKS["CUSTOM_PLUGINS"] = Status.FAIL
        else:
            file_perms = oct(stat("data/rabbitmq").st_mode & 0o777)
            if (
                (int(file_perms[2]) & 4)
                and (int(file_perms[3]) & 4)
                and (int(file_perms[4]) & 4)
            ):
                print_pass(f"Verified file permissions of data/rabbitmq")
                CHECKS["RABBITMQ"] = Status.PASS
            else:
                command = "sudo chmod -R 444 data/rabbitmq"
                set_directory_permission("data/rabbitmq", command)
                print_pass(
                    f"File permissions of data/rabbitmq are not accurate... Adding read permissions to data/rabbitmq"
                )
                CHECKS["RABBITMQ"] = Status.PASS
    except Exception as e:
        print_fail(
            f"Error occurred while verifying file permissions for data/rabbitmq"
        )
        CHECKS["RABBITMQ"] = Status.FAIL

    try:
        if not os.path.exists("data/ca_certs"):
            print_fail(
                f"Could not locate data/ca_certs directory (Please run `git reset --hard HEAD && git pull` and re-run the script.)"
            )
            CHECKS["ca_certs"] = Status.FAIL
        else:
            file_perms = oct(stat("data/ca_certs").st_mode & 0o777)
            if (
                (int(file_perms[2]) & 4)
                and (int(file_perms[2]) & 2)
                and (int(file_perms[2]) & 1)
                and (int(file_perms[3]) & 4)
                and (int(file_perms[3]) & 2)
                and (int(file_perms[3]) & 1)
                and (int(file_perms[4]) & 4)
                and (int(file_perms[4]) & 2)
                and (int(file_perms[4]) & 1)
            ):
                print_pass(f"Verified file permissions of data/ca_certs")
                CHECKS["ca_certs"] = Status.PASS
            else:
                command = "sudo chmod -R 777 data/ca_certs"
                set_directory_permission("data/ca_certs", command)
                print_pass(
                    f"File permissions of data/ca_certs are not accurate... Adding read permissions to data/ca_certs"
                )
                CHECKS["ca_certs"] = Status.PASS
    except Exception as e:
        print_fail(
            f"Error occurred while verifying file permissions for data/ca_certs"
        )
        CHECKS["ca_certs"] = Status.FAIL

    # start script
    try:
        if not os.path.exists("./start"):
            print_fail(
                f"Could not locate start script (Please run `git reset --hard HEAD && git pull` and re-run the script.)"
            )
            CHECKS["START"] = Status.FAIL
        else:
            file_perms = oct(stat("start").st_mode & 0o777)
            if (
                (int(file_perms[2]) & 1)
                and (int(file_perms[3]) & 1)
                and (int(file_perms[4]) & 1)
            ):
                print_pass(f"Verified file permissions of start script")
                CHECKS["START"] = Status.PASS
            else:
                command = "sudo chmod 555 ./start"
                set_directory_permission("start", command)
                print_pass(
                    f"File permissions of start script are not accurate... Adding execute permissions to start script"
                )
                CHECKS["START"] = Status.PASS
    except Exception as e:
        # print(e)
        print_fail(
            f"Error occurred while verifying file permissions for start script"
        )
        CHECKS["START"] = Status.FAIL

    # stop script
    try:
        if not os.path.exists("./stop"):
            print_fail(
                f"Could not locate stop script (Please run `git reset --hard HEAD && git pull` and re-run the script.)"
            )
            CHECKS["STOP"] = Status.FAIL
        else:
            file_perms = oct(stat("stop").st_mode & 0o777)
            if (
                (int(file_perms[2]) & 1)
                and (int(file_perms[3]) & 1)
                and (int(file_perms[4]) & 1)
            ):
                print_pass(f"Verified file permissions of stop script")
                CHECKS["STOP"] = Status.PASS
            else:
                command = "sudo chmod 555 ./stop"
                set_directory_permission("stop", command)
                print_pass(
                    f"File permissions of stop script are not accurate... Adding execute permissions to stop script"
                )
                CHECKS["STOP"] = Status.PASS
    except Exception as e:
        # print(e)
        print_fail(
            f"Error occurred while verifying file permissions for stop script"
        )
        CHECKS["STOP"] = Status.FAIL


def validate_port(port):
    try:
        if port == "":
            return True
        port = int(port)
        if 1 <= port <= 65535:
            return True
        return False
    except Exception as e:
        return False


def check_port(port):
    try:
        sock = socket.socket(socket.AF_INET, socket.SOCK_STREAM)
        result = sock.connect_ex(("127.0.0.1", port))
        if result == 0:
            print_fail(f"Port {port} is already in use.\033[0;37m\n")
            CHECKS["UI Port Check"] = Status.FAIL
            return False
        else:
            print_pass(f"Port {port} is available.\n")
            CHECKS["UI Port Check"] = Status.PASS
            return True
    except Exception as e:
        # print(e)
        print_warning(f"Could not verify Port information of the machine]n")
        CHECKS["UI Port Check"] = Status.NOT_VERIFIED


def pull_from_github():
    myenv = os.environ.copy()
    myenv["LC_ALL"] = "C"
    print("\nPulling updates from github.com...")
    pr1 = subprocess.Popen(
        ['git', 'diff', '-G.'],
        cwd=os.getcwd(),
        shell=False,
        stdout=subprocess.PIPE,
        stderr=subprocess.PIPE,
        env=myenv
    )
    (out, error) = pr1.communicate()
    out = out.decode("utf-8")
    error = error.decode("utf-8")

    print(out)

    if out == "" and error == "":
        pr1 = subprocess.Popen(
            ['git pull'],
            cwd=os.getcwd(),
            shell=True,
            stdout=subprocess.PIPE,
            stderr=subprocess.PIPE,
            env=myenv
        )
        (out, error) = pr1.communicate()
        error = error.decode("utf-8")
        out = out.decode("utf-8")
        print(out)
        if error != "" and ("Already up-to-date" not in out and "Already up to date" not in out):
            print_fail(f"Error while pulling the latest updates from github.\n{error}")
            print("\nRunning existing setup to install the Netskope CE...")
            return
        if "Already up-to-date" not in out and "Already up to date" not in out:
            print("\nThe latest changes has been pulled... Please run the setup script again...")
            exit(0)
    elif error != "":
        print(f"\nError while checking for git diff. {error}\n")
    else:   
        print("\n\033[1;31mThere are some local changes that might affect the installation. Can not proceed further. Please Remove the local changes and re-run the script.\033[0;37m\n")
        exit(1)


def migrate_mongo():
    print("\nVerifying mongo-data directory...")
    if os.path.exists("data/mongo-data/"):
        files = os.listdir("data/mongo-data/") 
        files = [x for x in files if not x.startswith('.')]

        if len(files) == 0 or "data" in files:
            print("mongo-data directory structure is already updated... ")
            return

        if not os.path.exists("data/mongo-data/data/db/"):
            print("\nCreating data/mongo-data/data/db directory...")
            os.makedirs("data/mongo-data/data/db/", mode=0o744)

        try:
            for _file in files:
                path_name = f"data/mongo-data/{_file}"
                if os.path.isdir(path_name):
                    shutil.copytree(path_name, f"data/mongo-data/data/db/{_file}")
                else:
                    shutil.copy(path_name, "data/mongo-data/data/db/")
            print("mongo-data directory structure updated successfully")

            # Change owner to 1001 after copying the data 
            if platform.system().lower() not in ["darwin"]:
                command = "sudo chown -R 1001:1001 data/mongo-data"
                set_directory_permission("data/mongo-data", command)
        except Exception as exc:
            print(f"Error while migrating mongo-data: {exc}")
    else:
        print_fail(
            f"Could not locate data/mongo-data directory (Please run `git reset --hard HEAD && git pull` and re-run the script.)"
        )
        exit(1)
        
def copy_env():
    while True:
        if AVAILABLE_INPUTS["DESTINATION_PATH"] == "":
            destination = input("> Enter the destination path (e.g. './backup_env'): ").strip()
        else:
            destination = input(f"\n> Enter the destination path for backup of .env (Current: \"{AVAILABLE_INPUTS['DESTINATION_PATH']}\"): ").strip()
        destination = AVAILABLE_INPUTS["DESTINATION_PATH"] if destination == "" else destination
        AVAILABLE_INPUTS["DESTINATION_PATH"] = destination
        put_env_variable(AVAILABLE_INPUTS)
        command = f"cp -r .env {destination}"
        try:
            p = subprocess.Popen(
                command.split(),
                shell=False,
                stderr=subprocess.PIPE,
                stdout=subprocess.PIPE,
                stdin=subprocess.PIPE,
            )
            out, err = p.communicate()
            if len(err) <= 0:
                print("backup completed...")
                break
            else:
                AVAILABLE_INPUTS["DESTINATION_PATH"] == ""
                raise Exception(err.decode("utf-8"))
        except Exception as e:
            if p:
                p.kill()
            print(
                f"Error occurred while taking backup. Error: {e}"
            )
            continue
        
def take_env_backup():
    if AVAILABLE_INPUTS["DESTINATION_PATH"] == "":
        isBackup = (
            input(
                "> Do you want to take backup of .env file? [y/n]: "
            )
            .strip()
            .lower()
        )
        if isBackup == "y" or isBackup == "yes":
            copy_env()
    else:
        copy_env()

def run():
    try:
        should_ignore = (
            True
            if (len(sys.argv) > 1 and sys.argv[1] == "--ignore-failures")
            else False
        )
        if len(sys.argv) > 1:
            if len(sys.argv) > 2:
                print("Invalid number of arguments provided.")
                exit()
            if "--ignore-failures" in sys.argv:
                should_ignore = True
            invalids = []
            for x in sys.argv[1:]:
                if x not in ["--ignore-failures"]:
                    invalids.append(x)
            if invalids != []:
                print(f"Invalid {invalids} flag(s) provided.")
                exit()
        print_banner()
        create_env_if_not_exist()
        get_all_existed_env_variable()  # Get already exsting env variables
        pull_from_github()

        ask_for_ce_version()
        ask_for_initial_inputs()
        check_prerequisites()
        migrate_mongo()
        check_and_apply_file_permissions()

        if (Status.FAIL in CHECKS.values()) or (Status.NOT_VERIFIED in [
            CHECKS.get('Podman-Plugin', None), CHECKS.get('Podman', None), CHECKS.get('Podman-Compose', None)
        ]):
            print(
                "\n\n\033[1;31mInstallation failed. One or more prerequisite checks are not met. Please address the minimum requirements and re-run the setup script.\033[0;37m\n"
            )
            if should_ignore:
                print(
                    "\033[1;31mIgnoring the failures... '--ignore-failures' flag applied.\033[0;37m"
                )
            else:
                exit()

        if Status.NOT_VERIFIED in CHECKS.values():
            shouldContinue = (
                getpass(
                    "\n\n\033[1;93mOne or more prerequisite checks could not be verified. Press Enter to continue \033[0;37m"
                )
                .strip()
                .lower()
            )


        # Ask for Protocol
        protocol = ""
        is_ssl_enabled = check_for_certs()
        if not is_ssl_enabled:
            while protocol not in ["http", "https"]:
                protocol = (
                    input(
                        "\nDo you want to access CE over HTTP, or HTTPS (HTTPS is recommended)? "
                    )
                    .strip()
                    .lower()
                )
                if protocol == "http":
                    print("Accessing CE over HTTP is not recommended\n")
                    confim = (
                        input(
                            "Do you still want to access CE over HTTP? (y/yes) "
                        )
                        .strip()
                        .lower()
                    )
                    if confim not in ["y", "yes"]:
                        protocol = ""
                        continue
                    else:
                        DEFAULT_INPUTS["ENABLE_TLS_V_1_2"][
                            "default"
                        ] = "TLSv1.3"
                        DEFAULT_INPUTS["ENABLE_TLS_V_1_2"]["skip"] = True
                elif protocol == "https":
                    DEFAULT_INPUTS["UI_PORT"]["default"] = 443
                    is_ssl_enabled = (
                        check_for_certs()
                    )  # Checking if SSL is enabled or not
                    if not is_ssl_enabled:
                        create_self_signed_ssl_certs()
                    print(
                        "\033[1;37mReplace ./data/ssl_certs/cte_cert.crt and ./data/ssl_certs/cte_cert_key.key files with your custom certificate and key files respectively to use custom SSL certificates.\033[0;37m"
                    )
                else:
                    print(
                        "Invalid input... Valid inputs are 'http' or 'https'.\n"
                    )
        else:
            DEFAULT_INPUTS["UI_PORT"]["default"] = 443

        print()

        # Ask for all configuration parameters
        for key, item in DEFAULT_INPUTS.items():
            data = ""
            if not item["skip"]:
                if key not in AVAILABLE_INPUTS:
                    if item["help"]:
                        print(item["help"])
                    if item.get("mandatory", False):
                        user_input = item.get("user_input")
                        if key == "JWT_SECRET":
                            data = ""
                            while data == "":
                                data = getpass(f"> {user_input}: ").strip()
                                if data == "":
                                    print(
                                        "JWT Secret can not be empty. Please try again.\n"
                                    )
                        elif key == "MAINTENANCE_PASSWORD":
                            data = "a"
                            confirm_data = "b"
                            while data != confirm_data or len(data) == 0:
                                data = "a"
                                confirm_data = "b"
                                data = getpass(f"> {user_input}: ").strip()
                                if data == "":
                                    print(
                                        "Maintenance password can not be empty. Please try again.\n"
                                    )
                                    continue

                                if (
                                    ("\\" in data)
                                    or ("/" in data)
                                    or ("'" in data)
                                    or ('"' in data)
                                ):
                                    print(
                                        "Maintenance password can not contain \\ / ' \" Please try again.\n"
                                    )
                                    continue

                                confirm_data = getpass(
                                    f"\n> Confirm maintenance password: "
                                ).strip()
                                if data != confirm_data:
                                    print(
                                        "Maintenance password and Confirm maintenance password do not match. Please try again.\n"
                                    )
                            data = f"'{data}'"
                        else:
                            data = input(f"> {user_input}: ").strip()
                    else:
                        user_input = item.get("user_input")
                        if user_input:
                            if key == "UI_PORT":
                                i = 0
                                while True: 
                                    if i >= 3:
                                        print("\033[1;37mPlease make sure the port on which you want to access the Netskope CE UI is available and Re-run the script.\033[0;37m")
                                        exit(1)
                                    data = input(
                                        f"> {user_input} (Default: \"{item['default']}\"): "
                                    ).strip()
                                    if validate_port(data):
                                        data = item['default'] if data == "" else data
                                        if check_port(int(data)):
                                            print(
                                                '\033[1;37mNOTE: This port will be used to access the Netskope CE UI. Please make sure that inbound traffic to this port is allowed.\n\033[0;37m'
                                            )
                                            break
                                    else:
                                        print("Invalid port provided... Port should be within 1 to 65535 range...\n")
                                    i += 1
                            else:
                                data = input(
                                    f"> {user_input} (Default: \"{item['default']}\"): "
                                ).strip()
                        else:
                            data = input(
                                f"> Enter {key} (Default: \"{item['default']}\"): "
                            ).strip()
                            

                else:
                    if key != "MAINTENANCE_PASSWORD":
                        if item["help"]:
                            print(item["help"])
                        user_input = item.get("user_input", None)
                        if user_input:
                            if key == "JWT_SECRET":
                                data = ""
                                while data == "":
                                    data = getpass(f"> {user_input}: ").strip()
                                    if data == "":
                                        print(
                                            "JWT Secret should not be empty. Please try again.\n"
                                        )
                            elif key == "UI_PORT":
                                i = 0
                                while True: 
                                    if i >= 3:
                                        print("\033[1;37mPlease make sure the port on which you want to access the Netskope CE UI is available and Re-run the script.\033[0;37m")
                                        exit(1)
                                    data = input(
                                        f"> {user_input} (Current: \"{AVAILABLE_INPUTS[key]}\"): "
                                    ).strip()
                                    if validate_port(data):
                                        data = AVAILABLE_INPUTS[key] if data == "" else data
                                        if check_port(int(data)):
                                            print(
                                                '\033[1;37mNOTE: This port will be used to access the Netskope CE UI. Please make sure that inbound traffic to this port is allowed.\n\033[0;37m'
                                            )
                                            break
                                    else:
                                        print("Invalid port provided... Port should be within 1 to 65535 range...\n")
                                    i += 1
                            else:
                                data = input(
                                    f'> {user_input} (Current: "{AVAILABLE_INPUTS[key]}"): '
                                ).strip()
                        else:
                            data = input(
                                f'> Enter {key} (Current: "{AVAILABLE_INPUTS[key]}"): '
                            ).strip()
                print("")
            data = data.strip() if isinstance(data, str) else data
            if not data:
                if key not in AVAILABLE_INPUTS:
                    data = item["default"]
                else:
                    data = AVAILABLE_INPUTS[key]
            data = data.strip() if isinstance(data, str) else data
            if key == "MAINTENANCE_PASSWORD_ESCAPED":
                data = urllib.parse.quote_plus(
                    AVAILABLE_INPUTS["MAINTENANCE_PASSWORD"].strip("'")
                )

            # if key == "BETA_OPT_IN":
            #     if data.lower() in ["y", "yes"]:
            #         AVAILABLE_INPUTS["CORE_TAG"] = CORE_BETA_DEFAULT
            #         AVAILABLE_INPUTS["UI_TAG"] = UI_BETA_DEFAULT
            #     else:
            #         AVAILABLE_INPUTS["CORE_TAG"] = CORE_DEFAULT
            #         AVAILABLE_INPUTS["UI_TAG"] = UI_DEFAULT

            if key == "ENABLE_TLS_V_1_2":
                if data.lower() in ["y", "yes"]:
                    data = "TLSv1.2 TLSv1.3"
                else:
                    data = "TLSv1.3"
            AVAILABLE_INPUTS[key] = data

            if key == "PULL_THREADS":
                AVAILABLE_INPUTS[key] = item.get("default", 4)

        code_tag_version = AVAILABLE_INPUTS.get("CORE_TAG", "").strip()
        if not "3-latest" in code_tag_version:
          # len == 1 as .gitkeep file will always be there in the ca_certs folder
          if (len(os.listdir('data/ca_certs')) == 1):
            # Ask for custom ca certs
            custom_ssl_confirm = (
                input(
                    "\n> Do you want to provide custom CA certs? (y/n): "
                )
                .strip()
                .lower()
            )
            if custom_ssl_confirm in ["y", "yes"]:
                print("\n\033[1;37mPlease add your certs to ./data/ca_certs and Re-run the script.\033[0;37m")
          else:
            print("CA certificate successfully found in the /data/ca_certs folder.")
        put_env_variable(AVAILABLE_INPUTS)
        take_env_backup()

        if isRedHat():
            print(
                "\nSetup completed successfully...\n\nExecute this command to start CE:\n  > sudo ./start"
            )
        else:
            print(
                "\nSetup completed successfully...\n\nExecute this command to start CE:\n  > ./start"
            )
        print(
            "\nPlease re-run the setup script to update any parameter.\n"
        )

    except KeyboardInterrupt as e:
        put_env_variable(AVAILABLE_INPUTS)
        print(
            "\nSetup stopped... The entered configurations will be saved...\n"
        )
    except Exception as e:
        print(e)

    print(
        "\nWarning: It is recommended to take an external backup of the .env file located in this directory."
    )


if __name__ == "__main__":
    run()
